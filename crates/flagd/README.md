# eatas-open-feature-flagd

[Generated by cargo-readme: `cargo readme > README.md`]::
FlagD Provider

A Rust implementation of the OpenFeature provider for flagd, enabling dynamic
feature flag evaluation in your applications.

### Core Features

* **Multiple Evaluation Modes**
  - RPC: High-performance gRPC-based evaluation with streaming support
  - REST: HTTP/OFREP protocol support with structured responses
  - In-Process: Embedded evaluation engine with file and gRPC sources

* **Advanced Targeting**
  - Semantic versioning comparisons
  - String operations (startsWith, endsWith)
  - Fractional rollouts with consistent hashing
  - Complex targeting rules with nested conditions

* **Caching Strategies**
* **Connection Management**

### Quick Start

```rust
use open_feature_flagd::{FlagdOptions, FlagdProvider, ResolverType};
use open_feature::provider::FeatureProvider;
use open_feature::EvaluationContext;

#[tokio::main]
async fn main() {
    // Connect to flagd service using REST
    let provider = FlagdProvider::new(FlagdOptions {
        host: "localhost".to_string(),
        port: 8016,
        resolver_type: ResolverType::Rest,
        ..Default::default()
    }).await.unwrap();

    // Evaluate a boolean flag
    let context = EvaluationContext::default()
        .with_targeting_key("user-123");
    let result = provider.resolve_bool_value("bool-flag", &context).await.unwrap();
    println!("Flag value: {}", result.value);
}
```

#### RPC Resolver with gRPC
```rust
use open_feature_flagd::{FlagdOptions, FlagdProvider, ResolverType};
use open_feature::provider::FeatureProvider;
use open_feature::EvaluationContext;

#[tokio::main]
async fn main() {
    // Connect using gRPC with retry and streaming options
    let provider = FlagdProvider::new(FlagdOptions {
        host: "localhost".to_string(),
        port: 8013,
        resolver_type: ResolverType::Rpc,
        retry_backoff_ms: 1000,
        retry_grace_period: 3,
        stream_deadline_ms: 60000,
        ..Default::default()
    }).await.unwrap();

    // Create context with targeting key and custom fields
    let context = EvaluationContext::default()
        .with_targeting_key("user-123")
        .with_custom_field("version", "1.0.0");

    // Evaluate different flag types
    let bool_result = provider.resolve_bool_value("feature-enabled", &context).await.unwrap();
    let string_result = provider.resolve_string_value("feature-variant", &context).await.unwrap();
    let int_result = provider.resolve_int_value("rollout-percentage", &context).await.unwrap();
}
```

#### In-Process Resolver with gRPC Source
```rust
use open_feature_flagd::{CacheSettings, FlagdOptions, FlagdProvider, ResolverType};
use open_feature::provider::FeatureProvider;
use open_feature::EvaluationContext;

#[tokio::main]
async fn main() {
    // Initialize in-process evaluation with gRPC source
    let provider = FlagdProvider::new(FlagdOptions {
        host: "localhost".to_string(),
        port: 8015,
        resolver_type: ResolverType::InProcess,
        selector: Some("my-flags".to_string()),
        cache_settings: Some(CacheSettings::default()),
        ..Default::default()
    }).await.unwrap();

    // Create evaluation context with targeting rules
    let context = EvaluationContext::default()
        .with_targeting_key("user-abc")
        .with_custom_field("environment", "production")
        .with_custom_field("semver", "2.1.0");

    // Evaluate flags with complex targeting
    let feature_enabled = provider.resolve_bool_value("dark-mode", &context).await.unwrap();
    let variant = provider.resolve_string_value("ui-version", &context).await.unwrap();
    let config = provider.resolve_struct_value("feature-config", &context).await.unwrap();
}
```

### Configuration

The provider can be configured through environment variables:

* `FLAGD_HOST`: Host address (default: "localhost")
* `FLAGD_PORT`: Port number (default: 8013 for gRPC, 8016 for REST)
* `FLAGD_CACHE`: Cache type ("lru", "mem", "disabled")
* `FLAGD_MAX_CACHE_SIZE`: Maximum cache entries
* `FLAGD_CACHE_TTL`: Cache TTL in seconds

### Value Types

Supports multiple value types:
* Boolean flags
* String flags
* Integer flags
* Float flags
* Structured flags (JSON objects)
